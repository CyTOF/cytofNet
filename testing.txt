
source("https://bioconductor.org/biocLite.R")
#biocLite()

#Remove scientific notation and set decimal places to 3
options(scipen=100, digits=3)

#Set CPU cores for parallel-related functions
cpucores <- 8
require(parallel)
options("mc.cores"=cpucores)

#Set CPU cores for doParallel-related functions
require(doParallel)
cores <- makeCluster(detectCores(), type='PSOCK')
registerDoParallel(cores)

#Convert FCS to CSV
require(flowCore)
source("R/fcs2csv.R")
fcs2csv(sample1.fcs, sample1.csv)

load("testing2.rdata")

#sample1 <- read.csv("sample1.csv")


#Create a vector of all variable names for the samples (used later for 'for' loops)
AllSamples <- c("sample1")

#Set global variables
#Set background noise threshold
#Values below this are set to 0
#Nikolay Samusik (X-shift/Vortex):
#	"Noise threshold is a way to remove low-level noise out of clustering variables.  All values (raw, before numerical transformation) that are below the threshold will be set to zero. This improves the separation of clusters in multidimensional datasets, because it increases the sparseness of expression vectors and thus alleviates the so-called 'curse of dimensionality'"
BackgroundNoiseThreshold <- 1

#Euclidean norm threshold - this is the square root of the sum of all the squares
EuclideanNormThreshold <- 1

#Choose a transformation function (any mathematical function)
transFun <- function (x) asinh(x)

#Set hyperbolic arc-sine factor (NB - asinh(x/5) is recommended for CyTOF and FACS data)
asinhFactor <- 5

source("R/downsampleByVar.R")

#Histograms to check distribution of data
source("R/transform.R")
  
colours <- c("red", "gold", "skyblue")

par(mfrow=c(1,3), cex=1.2)
  
for (i in 1:3)
{
  x <- as.matrix(get(AllSamples[1]))
  x <- x[,-which(colnames(x) %in% c("DNA.1", "DeadLive"))]
  x <- transform(x, BackgroundNoiseThreshold, EuclideanNormThreshold, transFun, asinhFactor)
    
  hist(data.matrix(x), main=paste("Hyperbolic arc-sine\nsample",  i), breaks=30, col=colours[i])
}

#Hexagonal binning to capture and summarise the 3-dimensional nature of CyTOF data
require(RColorBrewer)
rf <- colorRampPalette(rev(brewer.pal(9,"BuPu")))
source("R/facsplot.R")
x <- get(AllSamples[1])
facsplot("CD8", "HLA.DR", x, bins=400, main="FACS plot", xlim=c(-10,10), ylim=c(-10,10), x1=0, x2=5, y1=0, y2=5, cex=1.0, colramp=rf)

#All pairwise comparisons
rf <- colorRampPalette(rev(brewer.pal(9,"YlGn")))
counter <- 1
f <- list()
for (i in 1:3)
{
  for (j in 1:3)
  {
    f[[counter]] <- facsplot(colnames(x)[i], colnames(x)[j], x, bins=400, main="FACS plot", xlim=c(-10,10), ylim=c(-10,10), x1=0, x2=0, y1=0, y2=0, cex=1.0, colramp=rf)
    counter <- counter + 1
  }
}
library(gridExtra)
library(grid)
grid.arrange(f[[1]], f[[2]], f[[3]], f[[4]], f[[5]], f[[6]], f[[7]], f[[8]], f[[9]], ncol=3)

#Method:	Remove cells based on variance, identify cell populations with Gap Statistic, then identify main expressed/non-expressed markers in each population
#Redefine the clusGap function to incorporate parallel processing
x <- as.matrix(get(AllSamples[1]))
x <- x[,-which(colnames(x) %in% c("DNA.1", "DeadLive"))]
x <- transform(x, BackgroundNoiseThreshold, EuclideanNormThreshold, transFun, asinhFactor)
#Define a custom function for PAM (activate 'cluster.only')
CustomPAM <- function(x,k) list(cluster=pam(x, k, diss=FALSE, metric="manhattan", medoids=NULL, stand=FALSE, cluster.only=TRUE, do.swap=FALSE, keep.diss=FALSE, keep.data=FALSE, pamonce=TRUE, trace.lev=1))
source("testing/findk.R")
source("testing/clusGapKB.R")
gap <- findk(x=x, varianceFactor=5, FUNcluster=CustomPAM, K.max=40, B=50)

#First SE max=15
#Tibshirani et al. (2001)=15
#Dudoit & Fridlyand (2002)=40
#First max=15
#Global max=40

gap$Tab
       logW E.logW   gap   SE.sim
 [1,] 10.47   11.3 0.857 0.000703
 [2,] 10.28   11.3 1.036 0.001756
 [3,] 10.20   11.3 1.102 0.002086
 [4,] 10.12   11.3 1.175 0.002316
 [5,] 10.12   11.3 1.177 0.002303
 [6,] 10.09   11.3 1.203 0.002392
 [7,] 10.07   11.3 1.219 0.002329
 [8,] 10.04   11.3 1.239 0.002394
 [9,] 10.03   11.3 1.243 0.002597
[10,] 10.02   11.3 1.254 0.002776
[11,] 10.01   11.3 1.264 0.002709
[12,] 10.00   11.3 1.268 0.002729
[13,]  9.99   11.3 1.274 0.002594
[14,]  9.98   11.3 1.280 0.002648
[15,]  9.98   11.3 1.286 0.002479
[16,]  9.98   11.3 1.285 0.002383
[17,]  9.97   11.3 1.287 0.002326
[18,]  9.97   11.3 1.288 0.002299
[19,]  9.97   11.3 1.289 0.002210
[20,]  9.97   11.3 1.288 0.002098
[21,]  9.96   11.3 1.293 0.002139
[22,]  9.95   11.3 1.297 0.002105
[23,]  9.95   11.2 1.299 0.002037
[24,]  9.95   11.2 1.300 0.001994
[25,]  9.95   11.2 1.301 0.002015
[26,]  9.94   11.2 1.300 0.002076
[27,]  9.94   11.2 1.300 0.002132
[28,]  9.94   11.2 1.302 0.002164
[29,]  9.94   11.2 1.305 0.002155
[30,]  9.93   11.2 1.307 0.002091
[31,]  9.93   11.2 1.309 0.002076
[32,]  9.93   11.2 1.309 0.002042
[33,]  9.93   11.2 1.309 0.001958
[34,]  9.92   11.2 1.312 0.001975
[35,]  9.92   11.2 1.313 0.001863
[36,]  9.92   11.2 1.314 0.001825
[37,]  9.92   11.2 1.314 0.001767
[38,]  9.92   11.2 1.315 0.001768
[39,]  9.92   11.2 1.316 0.001781
[40,]  9.91   11.2 1.319 0.001781


par(mar=c(5,5,5,5), cex=1.5)
plot(gap, main="A, Gap statistic", cex.main=2, adj=0.5, pch=".", xlab="k, centers", ylab="Gap")
abline(v=4, col="steelblue", lty=2, lwd=2)
abline(v=15, col="steelblue", lty=2, lwd=2)

#Elbow method (looks at within-cluster sum of squares), i.e., cluster 'withinness')
#Silhouette coefficient
require(factoextra)
require(NbClust)
x <- as.matrix(get(AllSamples[1]))
x <- x[,-which(colnames(x) %in% c("DNA.1", "DeadLive"))]
x <- transform(x, BackgroundNoiseThreshold, EuclideanNormThreshold, transFun, asinhFactor)
source("R/findElbowSilhouette.R")
es <- findElbowSilhouette(x=x, varianceFactor=5, K.max=40, B=50)
require(cowplot)
par(mar=c(5,5,5,5), cex=1.5)
options(scipn=3)
plot_grid(es[[1]] + geom_vline(xintercept=4, linetype=2, colour="steelblue") + geom_vline(xintercept=15, linetype=2, colour="steelblue"),
	es[[2]] + geom_vline(xintercept=2, linetype=2, colour="steelblue") + geom_vline(xintercept=4, linetype=2, colour="steelblue") + geom_vline(xintercept=7, linetype=2, colour="steelblue") + geom_vline(xintercept=18, linetype=2, colour="steelblue"),
	labels=c("B", "C"), vjust=2.25, label_size=24, ncol=2, nrow=1)
options(scipen=999)

#IDEAL CLUSTERS
#k=4;
k=15;

#Re-perform clustering with the identified number of clusters, k
x <- as.matrix(get(AllSamples[1]))
x <- x[,-which(colnames(x) %in% c("DNA.1", "DeadLive"))]
x <- transform(x, BackgroundNoiseThreshold, EuclideanNormThreshold, transFun, asinhFactor)
source("R/clusterWithk.R")
#Define a custom function for PAM
CustomPAM <- function(x,k) list(cluster=pam(x, k, diss=FALSE, metric="manhattan", medoids=NULL, stand=FALSE, cluster.only=FALSE, do.swap=TRUE, keep.diss=TRUE, keep.data=TRUE, pamonce=FALSE, trace.lev=1))
gap <- clusterWithk(x=x, varianceFactor=5, FUNcluster=CustomPAM, k=k, lowerPercentile=12.5, upperPercentile=12.5, p=0.05)

[1] "1, 2.89992418498863, CD56+, CD8-CD16-"
[1] "2, 6.29264594389689, HLA.DR+, CD56-GB-IL.10-"
[1] "3, 6.54852160727824, CD8+, HLA.DR-CD56-"
[1] "4, 10.1307808946171, CD56+, HLA.DR-CXCR5-"
[1] "5, 10.2824109173616, CD8+CD56+, CXCR5-"
[1] "6, 5.28335860500379, CD8+CD56+, HLA.DR-CD4-CD27-ICOS-CXCR5-"
[1] "7, 5.5724033358605, CD27+, CD56-"
[1] "8, 4.14613343442002, CD56+, HLA.DR-CD8-"
[1] "9, 11.7181576952237, CD8+CD56+, CXCR5-"
[1] "10, 3.82391963608795, HLA.DR+, CD8-CD56-"
[1] "11, 3.64859742228961, CD4+CD27+, CD8-CD56-CXCR5-"
[1] "12, 10.7136087945413, CXCR5+, CD8-CD56-GB-"
[1] "13, 5.77141774071266, CD8+, CD56-"
[1] "14, 4.33093252463988, HLA.DR+CXCR5+, CD8-CD16-"
[1] "15, 8.83718726307809, CD4+, HLA.DR-CD8-CD56-"

#Plot the signature for each cluster
require(RColorBrewer)
pick.col <- brewer.pal(10, "RdBu")
my_palette <- c(colorRampPalette(rev(pick.col))(200))
source("testing/plotSignatures.R")
plotSignatures(gap, my_palette, cexlab=1.2, cexlegend=1.2, labDegree=80)

#Complex heatmap
#Set colour
require(RColorBrewer)
myCol <- colorRampPalette(c("dodgerblue", "black", "gold"))(100)
myBreaks <- seq(-3, 3, length.out=100)

require(ComplexHeatmap)
require(circlize)
require(cluster)
require("RColorBrewer")

x <- as.matrix(get(AllSamples[1]))
x <- x[,-which(colnames(x) %in% c("DNA.1", "DeadLive"))]
x <- transform(x, BackgroundNoiseThreshold, EuclideanNormThreshold, transFun, asinhFactor)
x <- downsampleByVar(x, varianceFactor=5)
x <- scale(x)

#Create a sample boxplot / violin plot
  sampleBoxplot <- HeatmapAnnotation(boxplot=anno_boxplot(x, which="column", pch=".", size=unit(1.0, "mm"), border=TRUE, axis=TRUE))

  annCD4 <- gap$clustering
  annCD4[which(annCD4 %in% (grep("CD4\\+", gap$PositiveMarkers, invert=FALSE)))] <- "Positive"
  annCD4[which(annCD4 %in% (grep("CD4\\+", gap$PositiveMarkers, invert=TRUE)))] <- "Neutral/Neg."

  annCD8 <- gap$clustering
  annCD8[which(annCD8 %in% (grep("CD8\\+", gap$PositiveMarkers, invert=FALSE)))] <- "Positive"
  annCD8[which(annCD8 %in% (grep("CD8\\+", gap$PositiveMarkers, invert=TRUE)))] <- "Neutral/Neg."

  annCD56 <- gap$clustering
  annCD56[which(annCD56 %in% (grep("CD56\\+", gap$PositiveMarkers, invert=FALSE)))] <- "Positive"
  annCD56[which(annCD56 %in% (grep("CD56\\+", gap$PositiveMarkers, invert=TRUE)))] <- "Neutral/Neg."

  rowAnn <- rowAnnotation(data.frame(CD4=annCD4, CD8=annCD8, CD56=annCD56), col=list(CD4=c("Positive"="skyblue", "Neutral/Neg."="white"), CD8=c("Positive"="limegreen", "Neutral/Neg."="white"), CD56=c("Positive"="purple", "Neutral/Neg."="white")), show_legend=TRUE, width=unit(1, "cm"))

png("complexheatmap.png", 700, 1100)
par(mar=c(2,2,2,2), cex=0.8)

hmap <- Heatmap(x, name="Cell Z-score", col=colorRamp2(myBreaks, myCol),
    heatmap_legend_param = list(color_bar = "continuous", legend_direction = "vertical",
    legend_width = unit(5, "cm"), title_position = "lefttop"),
		split=paste0(gap$clustering, "\n", round(gap$iPercentage[gap$clustering], 2), "%"), gap=unit(1.5, "mm"),
		row_title="Genes", row_title_side="left", row_title_gp=gpar(fontsize=10,  fontface="bold"), show_row_names=FALSE, row_names_gp=gpar(fontsize=6, fontface="bold"), row_names_max_width=unit(2, "cm"),
		column_title="", column_title_side="top", column_title_gp=gpar(fontsize=10, fontface="bold"), column_title_rot=0, show_column_names=TRUE,
		clustering_distance_columns=function(x) as.dist(1-cor(t(x))), clustering_method_columns="ward.D2",
		clustering_distance_rows=function(x) as.dist(1-cor(t(x))), clustering_method_rows="ward.D2",
		row_dend_width=unit(20,"mm"), column_dend_height=unit(20,"mm"),
		top_annotation=sampleBoxplot, top_annotation_height=unit(3, "cm"))

draw(hmap + rowAnn, heatmap_legend_side="right", annotation_legend_side="right")
dev.off()



#Graph and minimum spanning tree
require(igraph) 

g <- graph.adjacency(
  as.matrix(as.dist(cor(t(gap$medoids), method="spearman"))),

  mode="undirected",
  weighted=TRUE,
  diag=FALSE
)

#Simplfy the adjacency object
g <- simplify(g, remove.multiple=TRUE, remove.loops=TRUE)

#Colour negative correlation edges as blue
E(g)[which(E(g)$weight<0)]$color <- "grey75"

#Colour positive correlation edges as red
E(g)[which(E(g)$weight>0)]$color <- "grey75"

#Convert edge weights to absolute values
E(g)$weight <- abs(E(g)$weight)

#Remove edges below absolute Spearman correlation 0.6
g <- delete_edges(g, E(g)[which(E(g)$weight<0.6)])

#Assign names to the graph vertices (optional)
V(g)$name <- V(g)$name
V(g)$label <- paste(gap$PositiveMarkers, gap$NegativeMarkers, sep="\n")

#Change shape of graph vertices
V(g)$shape <- "sphere"

#Change colour of graph vertices
cd4t <- grep("CD4\\+", gap$PositiveMarkers)
cd8t <- grep("CD8\\+", gap$PositiveMarkers)
NK <- grep("CD56\\+", gap$PositiveMarkers)
V(g)[cd4t]$color <- "skyblue"
V(g)[cd8t]$color <- "limegreen"
V(g)[NK]$color <- "purple"

#Change colour of vertex frames
V(g)$vertex.frame.color <- "white"

#Scale the size of the vertices to be proportional to the numer of cells in each
vSizes <- gap$iPercentage * 2

#Amplify or decrease the width of the edges
edgeweights <- E(g)$weight * 2.0

#Convert the graph adjacency object into a minimum spanning tree based on Prim's algorithm
mst <- mst(g, algorithm="prim")

V(mst)[cd4t]$color <- "skyblue"
V(mst)[cd8t]$color <- "limegreen"
V(mst)[NK]$color <- "purple"

par(mfrow=c(1,2))
#Plot the tree object
plot(
  g,
  layout=layout.fruchterman.reingold,
  edge.curved=FALSE,
  vertex.size=vSizes,
  vertex.label.dist=-0.5,
  vertex.label.color="black",
  asp=FALSE,
  vertex.label.cex=0.8,
  edge.width=edgeweights,
  edge.arrow.mode=0,
  main="Graph"
)

plot(
  mst,
  layout=layout.fruchterman.reingold,
  edge.curved=TRUE,
  vertex.size=vSizes,
  vertex.label.dist=-0.5,
  vertex.label.color="black",
  asp=FALSE,
  vertex.label.cex=0.8,
  edge.width=edgeweights,
  edge.arrow.mode=0,
  main="Minimum spanning tree"
)

mst.communities <- edge.betweenness.community(mst, directed=FALSE)
mst.clustering <- make_clusters(mst, membership=mst.communities$membership)
V(mst)$color <- mst.communities$membership + 1

plot(
  mst.clustering, mst,
  layout=layout.fruchterman.reingold,
  edge.curved=TRUE,
  vertex.size=vSizes,
  vertex.label.dist=-0.5,
  vertex.label.color="black",
  asp=FALSE,
  vertex.label.cex=0.8,
  edge.width=edgeweights,
  edge.arrow.mode=0,
  main="communities"
)



















g <- graph.adjacency(as.matrix(dist(gap$medoids)), mode="directed", weighted=TRUE, diag=TRUE)
V(g)$name <- V(g)$name
V(g)$label <- paste(gap$PositiveMarkers, gap$NegativeMarkers, sep="\n")
V(g)$color <- "white"
V(g)$shape <- "sphere"
V(g)$vertex.frame.color <- "white"
E(g)$color <- "grey"
E(g)$arrow.size <- 1.0

mst <- as.undirected(minimum.spanning.tree(g))
#mst <- as.directed(minimum.spanning.tree(g))

cd4t <- grep("CD4\\+", gap$PositiveMarkers)
cd8t <- grep("CD8\\+", gap$PositiveMarkers)
NK <- grep("CD56\\+", gap$PositiveMarkers)
hla <- grep("HLA.DR\\+", gap$PositiveMarkers)

#Colour the vertices for each cell-type
V(g)[cd4t]$color <- "skyblue"
V(g)[cd8t]$color <- "forestgreen"
V(g)[NK]$color <- "gold"
V(g)[hla]$color <- "red1"

V(mst)[cd4t]$color <- "skyblue"
V(mst)[cd8t]$color <- "forestgreen"
V(mst)[NK]$color <- "gold"
V(mst)[hla]$color <- "red1"

par(mar=c(1,1,1,1), cex=1.0, mfrow=c(1,2))

plot(g, main="Directed graph", layout=layout.graphopt, vertex.size=(gap$iPercentage)*3, vertex.label.dist=0, vertex.label.color="black", asp=FALSE, vertex.label.cex=0.8, edge.arrow.mode=1)

plot(mst, main="Minimal spanning tree", layout=layout.graphopt, vertex.size=(gap$iPercentage)*3, vertex.label.dist=0, vertex.label.color="black", asp=FALSE, vertex.label.cex=0.5, edge.arrow.mode=0, edge.width=3)
legend("topleft", bty="n", cex=0.8, title="Cell-type", c("Natural killer (CD56+)", "T (CD4+)", "T (CD8+)"), fill=c("plum", "skyblue", "lawngreen"), horiz=FALSE)

	###

	require(plotrix)
	V(g)$label <- V(g)$name
	mst <- as.undirected(minimum.spanning.tree(g))

	plot.new()
	table <- data.frame(c(1:k), round(gap$iPercentage, 2), gap$PositiveMarkers, gap$NegativeMarkers)
	colnames(table) <- c("Cluster #", "% cells", "Pos markers", "Neg markers")
	addtable2plot(0.05, 0.05, table, cex=0.6, bg="grey", lwd=3, bty="o", display.rownames=FALSE, hlines=TRUE, vlines=TRUE, title="Markers by cluster #")

	plot(mst, main="Minimal spanning tree", layout=layout.graphopt, vertex.size=(gap$iPercentage)*3, vertex.label.dist=0, vertex.label.color="black", asp=FALSE, vertex.label.cex=1.75, edge.arrow.mode=0, edge.width=3)
	legend("topleft", bty="n", cex=0.8, title="Cell-type", c("Natural killer (CD56+)", "T (CD4+)", "T (CD8+)"), fill=c("plum", "skyblue", "lawngreen"), horiz=FALSE)
dev.off()

#Look at cluster #2 and 24 individually
c2 <- x[gap$clustering==2,]
g2 <- graph.adjacency(as.matrix(dist(t(c2))), mode="directed", weighted=TRUE, diag=TRUE)
V(g2)$name <- V(g2)$name
V(g2)$color <- "gold"
V(g2)$shape <- "sphere"
V(g2)$vertex.frame.color <- "white"
E(g2)$color <- "grey"
E(g2)$arrow.size <- 1.0
mst2 <- as.directed(minimum.spanning.tree(g2))

c24 <- x[gap$clustering==24,]
g24 <- graph.adjacency(as.matrix(dist(t(c24))), mode="directed", weighted=TRUE, diag=TRUE)
V(g24)$name <- V(g24)$name
V(g24)$color <- "gold"
V(g24)$shape <- "sphere"
V(g24)$vertex.frame.color <- "white"
E(g24)$color <- "grey"
E(g24)$arrow.size <- 1.0
mst24 <- as.directed(minimum.spanning.tree(g24))

c17 <- x[gap$clustering==17,]
g17 <- graph.adjacency(as.matrix(dist(t(c17))), mode="directed", weighted=TRUE, diag=TRUE)
V(g17)$name <- V(g24)$name
V(g17)$color <- "gold"
V(g17)$shape <- "sphere"
V(g17)$vertex.frame.color <- "white"
E(g17)$color <- "grey"
E(g17)$arrow.size <- 1.0
mst17 <- as.directed(minimum.spanning.tree(g17))

c5 <- x[gap$clustering==5,]
g5 <- graph.adjacency(as.matrix(dist(t(c5))), mode="directed", weighted=TRUE, diag=TRUE)
V(g5)$name <- V(g24)$name
V(g5)$color <- "gold"
V(g5)$shape <- "sphere"
V(g5)$vertex.frame.color <- "white"
E(g5)$color <- "grey"
E(g5)$arrow.size <- 1.0
mst5 <- as.directed(minimum.spanning.tree(g5))

pdf("MST.clusters.pdf", width=15, height=7)
	par(mar=c(1,1,1,1), cex=1.0, mfrow=c(1,2))

	plot(g2, main="Directed graph\nCluster 2", layout=layout.graphopt, vertex.size=apply(c2, 2, mean)*2, vertex.label.dist=0, vertex.label.color="black", asp=FALSE, vertex.label.cex=1.0, edge.arrow.mode=1)

	plot(mst2, main="Minimal spanning tree\nCluster 2", layout=layout_nicely, vertex.size=apply(c2, 2, mean)*2, vertex.label.dist=0, vertex.label.color="black", asp=FALSE, vertex.label.cex=0.6, edge.arrow.mode=1, edge.width=3)

	###

	plot(g24, main="Directed graph\nCluster 24", layout=layout.graphopt, vertex.size=apply(c24, 2, mean)*2, vertex.label.dist=0, vertex.label.color="black", asp=FALSE, vertex.label.cex=1.0, edge.arrow.mode=1)

	plot(mst24, main="Minimal spanning tree\nCluster 24", layout=layout_nicely, vertex.size=apply(c24, 2, mean)*2, vertex.label.dist=0, vertex.label.color="black", asp=FALSE, vertex.label.cex=0.6, edge.arrow.mode=1, edge.width=3)

	###

	plot(g17, main="Directed graph\nCluster 17", layout=layout.graphopt, vertex.size=apply(c17, 2, mean)*2, vertex.label.dist=0, vertex.label.color="black", asp=FALSE, vertex.label.cex=1.0, edge.arrow.mode=1)

	plot(mst17, main="Minimal spanning tree\nCluster 17", layout=layout_nicely, vertex.size=apply(c17, 2, mean)*2, vertex.label.dist=0, vertex.label.color="black", asp=FALSE, vertex.label.cex=0.6, edge.arrow.mode=1, edge.width=3)

	###

	plot(g5, main="Directed graph\nCluster 5", layout=layout.graphopt, vertex.size=apply(c5, 2, mean)*2, vertex.label.dist=0, vertex.label.color="black", asp=FALSE, vertex.label.cex=1.0, edge.arrow.mode=1)

	plot(mst5, main="Minimal spanning tree\nCluster 5", layout=layout_nicely, vertex.size=apply(c5, 2, mean)*2, vertex.label.dist=0, vertex.label.color="black", asp=FALSE, vertex.label.cex=0.6, edge.arrow.mode=1, edge.width=3)
dev.off()





#Traveling Salesman
require(TSP)
pdf("TSP.pdf")
	par(mar=c(1,1,1,1), cex=1.0)

	i <- ETSP(gap$medoids)
	tour <- solve_TSP(i, method="nn", control="concorde")
	tour_length(tour)

	plot(i, tour, tour_col="red4")
dev.off()






x <- as.matrix(get(AllSamples[15]))
x <- x[,-which(colnames(x) %in% c("DNA.1", "DeadLive"))]
	
x <- x[apply(x, 1, FUN=function(x) sqrt(sum(x^2)))>EuclideanNormThreshold,]
NoiseCorrected <- x
NoiseCorrected[NoiseCorrected<BackgroundNoiseThreshold] <- 0
x <- transformation(NoiseCorrected/asinhFactor)

#Select out the top markers based on variance
variances <- apply(x, 1, var)
x <- x[order(variances, decreasing=TRUE),]
x2 <- x[1:round((nrow(x)/varianceFactor),0),]

#Voronoi diagram
library(tripack)
x <- prcomp(x2)$x[,1]
y <- prcomp(x2)$x[,2]
plot(voronoi.mosaic(x, y))
segments(x[i[,1]], y[i[,1]], x[i[,2]], y[i[,2]], lwd=3, col="grey")  
points(x, y, pch=3, cex=2, lwd=3)
box()

# Delaunay triangulation
# See also the "deldir" package
plot(tri.mesh(x,y))
plot(voronoi.mosaic(x, y), add=T, col="grey")
points(x, y, pch=3, cex=2, lwd=3)
























###


par(mar=c(5,5,5,5), cex=0.8)

		###

		#k-means dimensions plot

		clusplot(x, gap$clustering, main="kmeans clustering", color=TRUE, shade=TRUE, labels=1, lines=0)
		plotcluster(x, method="dc", gap$clustering, pch=19, xlab="Dimension 1", ylab="Dimension 2")
		plotcluster(x, method="wnc", gap$clustering, pch=19, xlab="Dimension 1", ylab="Dimension 2")

		###
























###

#Display the data as a pie chart
################################

StimulatedSamples <- AllSamples[grep("*_S_*", AllSamples)]
NonStimulatedSamples <- AllSamples[grep("*_NS_*", AllSamples)]

NewAllSamples <- c(NonStimulatedSamples, StimulatedSamples)

clusterinfo <- read.table("Variance/CountInformation.tsv", header=TRUE, sep="\t")

i <- 1

while (i < length(NewAllSamples))
{
	PieInfoSam1 <- clusterinfo[which(clusterinfo[,1] %in% NewAllSamples[i]),]
	Sam1Percentages <- PieInfoSam1[,3]
	Sam1Markers <- c()
	for (j in 1:nrow(PieInfoSam1))
	{
		Sam1Markers <- c(Sam1Markers, paste(paste(PieInfoSam1[j,4], sep="", collapse=""), paste(PieInfoSam1[j,5], sep="", collapse=""), sep="\n"))
	}

	PieInfoSam2 <- clusterinfo[which(clusterinfo[,1] %in% NewAllSamples[i+1]),]
	Sam2Percentages <- PieInfoSam2[,3]
	Sam2Markers <- c()
	for (j in 1:nrow(PieInfoSam2))
	{
		Sam2Markers <- c(Sam2Markers, paste(paste(PieInfoSam2[j,4], sep="", collapse=""), paste(PieInfoSam2[j,5], sep="", collapse=""), sep="\n"))
	}

	PieInfoSam3 <- clusterinfo[which(clusterinfo[,1] %in% NewAllSamples[i+2]),]
	Sam3Percentages <- PieInfoSam3[,3]
	Sam3Markers <- c()
	for (j in 1:nrow(PieInfoSam3))
	{
		Sam3Markers <- c(Sam3Markers, paste(paste(PieInfoSam3[j,4], sep="", collapse=""), paste(PieInfoSam3[j,5], sep="", collapse=""), sep="\n"))
	}

	pdf(paste("Variance/PieChart", gsub("_[A-Za-z0-9]*_", "_", NewAllSamples[i]), ".pdf", sep=""))
	{
		par(mar=c(5.5,5.5,5.5,5.5), cex=0.8, mfrow=c(2,2))

		pie(Sam1Percentages, labels=paste(Sam1Markers, paste(round(Sam1Percentages, 2), "%"), sep=", "), cex=0.3, cex.main=0.8, col=rainbow(length(Sam1Markers)), main=NewAllSamples[i])
		pie(Sam2Percentages, labels=paste(Sam2Markers, paste(round(Sam2Percentages, 2), "%"), sep=", "), cex=0.3, cex.main=0.8, col=rainbow(length(Sam2Markers)), main=NewAllSamples[i+1])
		pie(Sam3Percentages, labels=paste(Sam3Markers, paste(round(Sam3Percentages, 2), "%"), sep=", "), cex=0.3, cex.main=0.8, col=rainbow(length(Sam3Markers)), main=NewAllSamples[i+2])

		#biocLite("plotrix")
		library(plotrix)

		#pie3D(iClusterPercentages, labels=paste(Sam1Markers, paste(round(Sam1Percentages, 2), "%"), sep=", "), cex=0.3, cex.main=0.8, col=rainbow(length(Sam1Markers)), main=NewAllSamples[i], explode=0.1)
		#pie3D(iClusterPercentages, labels=paste(Sam2Markers, paste(round(Sam2Percentages, 2), "%"), sep=", "), cex=0.3, cex.main=0.8, col=rainbow(length(Sam2Markers)), main=NewAllSamples[i+1], explode=0.1)
		#pie3D(iClusterPercentages, labels=paste(Sam3Markers, paste(round(Sam3Percentages, 2), "%"), sep=", "), cex=0.3, cex.main=0.8, col=rainbow(length(Sam3Markers)), main=NewAllSamples[i+2], explode=0.1)
	}
	dev.off()

	i <- i + 3
	print(i)
}



#####
#END#
#####
