
source("https://bioconductor.org/biocLite.R")
#biocLite()

#Remove scientific notation and set decimal places to 3
options(scipen=100, digits=3)

#Set CPU cores for parallel-related functions
cpucores <- 8
require(parallel)
options("mc.cores"=cpucores)

#Set CPU cores for doParallel-related functions
require(doParallel)
cores <- makeCluster(detectCores(), type='PSOCK')
registerDoParallel(cores)

#Convert FCS to CSV
require(flowCore)
source("testing/fcs2csv.R")
fcs2csv(sample1.fcs, sample1.csv)

load("testing/testing2.rdata")

#sample1 <- read.csv("sample1.csv")


#Create a vector of all variable names for the samples (used later for 'for' loops)
AllSamples <- c("sample1")

#Set global variables
#Set background noise threshold
#Values below this are set to 0
#Nikolay Samusik (X-shift/Vortex):
#	"Noise threshold is a way to remove low-level noise out of clustering variables.  All values (raw, before numerical transformation) that are below the threshold will be set to zero. This improves the separation of clusters in multidimensional datasets, because it increases the sparseness of expression vectors and thus alleviates the so-called 'curse of dimensionality'"
BackgroundNoiseThreshold <- 1

#Euclidean norm threshold - this is the square root of the sum of all the squares
EuclideanNormThreshold <- 1

#Choose a transformation function (any mathematical function)
transFun <- function (x) asinh(x)

#Set hyperbolic arc-sine factor (NB - asinh(x/5) is recommended for CyTOF and FACS data)
asinhFactor <- 5

#Histograms to check distribution of data
par(mfrow=c(1,3), cex=1.2)
source("testing/transform.R")
x <- as.matrix(get(AllSamples[1]))
x <- x[,-which(colnames(x) %in% c("DNA.1", "DeadLive"))]
x <- transform(x, BackgroundNoiseThreshold, EuclideanNormThreshold, transFun, asinhFactor)
hist(data.matrix(x), main="Hyperbolic arc-sine\nsample 1", breaks=30, col="red")
hist(data.matrix(x), main="Hyperbolic arc-sine\nsample 2", breaks=30, col="gold")
hist(data.matrix(x), main="Hyperbolic arc-sine\nsample 3", breaks=30, col="skyblue")

#Hexagonal binning to capture and summarise the 3-dimensional nature of CyTOF data
require(RColorBrewer)
rf <- colorRampPalette(rev(brewer.pal(9,"BuPu")))
source("testing/facsplot.R")
facsplot("CD8", "HLA.DR", get(AllSamples[1]), bins=400, main="FACS plot", xlim=c(-10,10), ylim=c(-10,10), x1=0, x2=5, y1=0, y2=5, cex=1.0, colramp=rf) # HexBin ignores NAs and doesn't count them whilst binning

#Method:	Remove cells based on variance, identify cell populations with Gap Statistic, then identify main expressed/non-expressed markers in each population
#Redefine the clusGap function to incorporate parallel processing
x <- as.matrix(get(AllSamples[1]))
x <- x[,-which(colnames(x) %in% c("DNA.1", "DeadLive"))]
x <- transform(x, BackgroundNoiseThreshold, EuclideanNormThreshold, transFun, asinhFactor)
#Define a custom function for PAM (activate 'cluster.only')
CustomPAM <- function(x,k) list(cluster=pam(x, k, diss=FALSE, metric="manhattan", medoids=NULL, stand=FALSE, cluster.only=TRUE, do.swap=FALSE, keep.diss=FALSE, keep.data=FALSE, pamonce=TRUE, trace.lev=1))
source("testing/findk.R")
source("testing/clusGapKB.R")
gap <- findk(x=x, varianceFactor=10, FUNcluster=CustomPAM, K.max=40, B=50)

#First SE max=11
#Tibshirani et al. (2001)=6
#Dudoit & Fridlyand (2002)=39
#First max=11
#Global max=39

gap$Tab
      logW E.logW   gap   SE.sim
 [1,] 9.74   10.6 0.863 0.000852
 [2,] 9.53   10.6 1.062 0.002341
 [3,] 9.49   10.6 1.093 0.002588
 [4,] 9.41   10.6 1.160 0.002820
 [5,] 9.39   10.6 1.180 0.003057
 [6,] 9.36   10.6 1.199 0.003161
 [7,] 9.36   10.6 1.202 0.003125
 [8,] 9.33   10.6 1.222 0.003133
 [9,] 9.32   10.6 1.226 0.003054
[10,] 9.31   10.5 1.240 0.002815
[11,] 9.30   10.5 1.243 0.002590
[12,] 9.30   10.5 1.243 0.002652
[13,] 9.29   10.5 1.245 0.002731
[14,] 9.28   10.5 1.255 0.002558
[15,] 9.28   10.5 1.256 0.002417
[16,] 9.27   10.5 1.264 0.002301
[17,] 9.26   10.5 1.269 0.002277
[18,] 9.26   10.5 1.270 0.002199
[19,] 9.25   10.5 1.273 0.002214
[20,] 9.25   10.5 1.272 0.002106
[21,] 9.25   10.5 1.272 0.002050
[22,] 9.25   10.5 1.274 0.001980
[23,] 9.24   10.5 1.276 0.001935
[24,] 9.24   10.5 1.276 0.001895
[25,] 9.24   10.5 1.280 0.001806
[26,] 9.23   10.5 1.284 0.001764
[27,] 9.23   10.5 1.284 0.001794
[28,] 9.23   10.5 1.285 0.001775
[29,] 9.23   10.5 1.285 0.001780
[30,] 9.22   10.5 1.285 0.001776
[31,] 9.22   10.5 1.286 0.001715
[32,] 9.22   10.5 1.288 0.001779
[33,] 9.22   10.5 1.288 0.001862
[34,] 9.21   10.5 1.290 0.001881
[35,] 9.21   10.5 1.290 0.001875
[36,] 9.21   10.5 1.291 0.001885
[37,] 9.21   10.5 1.292 0.001903
[38,] 9.21   10.5 1.293 0.001902
[39,] 9.20   10.5 1.296 0.001885
[40,] 9.20   10.5 1.295 0.001863

par(mar=c(3,3,3,3), cex=1.5)
plot(gap, main="A", cex.main=3, adj=0.5, pch=16)
abline(v=6, col="steelblue", lty=2, lwd=2)
abline(v=11, col="steelblue", lty=2, lwd=2)

#Elbow method (looks at within-cluster sum of squares), i.e., cluster 'withinness')
#Silhouette coefficient
require(factoextra)
require(NbClust)
x <- as.matrix(get(AllSamples[1]))
x <- x[,-which(colnames(x) %in% c("DNA.1", "DeadLive"))]
x <- transform(x, BackgroundNoiseThreshold, EuclideanNormThreshold, transFun, asinhFactor)
source("testing/findElbowSilhouette.R")
es <- findElbowSilhouette(x=x, varianceFactor=10, K.max=40, B=50)
require(cowplot)
par(mar=c(5,5,5,5), cex=1.5)
options(scipn=3)
plot_grid(es[[1]] + geom_vline(xintercept=2, linetype=2, colour="steelblue") + geom_vline(xintercept=6, linetype=2, colour="steelblue") + geom_vline(xintercept=11, linetype=2, colour="steelblue"),
	es[[2]] + geom_vline(xintercept=2, linetype=2, colour="steelblue") + geom_vline(xintercept=6, linetype=2, colour="steelblue") + geom_vline(xintercept=11, linetype=2, colour="steelblue"),
	labels=c("B", "C"), vjust=2.25, label_size=24, ncol=2, nrow=1)
options(scipen=999)

#IDEAL CLUSTERS
k=6; k=11


#Re-perform clustering with the identified number of clusters, k
x <- as.matrix(get(AllSamples[1]))
x <- x[,-which(colnames(x) %in% c("DNA.1", "DeadLive"))]
x <- transform(x, BackgroundNoiseThreshold, EuclideanNormThreshold, transFun, asinhFactor)
source("testing/clusterWithk.R")
#Define a custom function for PAM
CustomPAM <- function(x,k) list(cluster=pam(x, k, diss=FALSE, metric="manhattan", medoids=NULL, stand=FALSE, cluster.only=FALSE, do.swap=TRUE, keep.diss=TRUE, keep.data=TRUE, pamonce=FALSE, trace.lev=1))
gap <- clusterWithk(x=x, varianceFactor=10, FUNcluster=CustomPAM, k=k, lowerPercentile=12.5, upperPercentile=12.5, p=0.05)

[1] "1, 3.93290371493556, CD56+, CD8-CD16-"
[1] "2, 7.40144048521607, HLA.DR+, CD56-GB-"
[1] "3, 11.4101592115239, CD8+, CD56-"
[1] "4, 14.5090978013647, CD56+, HLA.DR-CXCR5-"
[1] "5, 15.4473085670963, CD56+, CXCR5-"
[1] "6, 7.12661106899166, CD8+CD56+, HLA.DR-CD4-CD27-LAG3-ICOS-CXCR5-"
[1] "7, 5.43025018953753, CD27+, CD56-CXCR5-"
[1] "8, 12.5947687642153, CD8+CD56+, CXCR5-"
[1] "9, 6.31159969673995, CD4+, CD8-CD56-CXCR5-IL.10-"
[1] "10, 13.0307050796058, CXCR5+, CD8-CD56-GB-"
[1] "11, 2.80515542077331, HLA.DR+CXCR5+, CD8-CD56-CD16-"

#Plot the signature for each cluster
require(RColorBrewer)
pick.col <- brewer.pal(10, "RdBu")
my_palette <- c(colorRampPalette(rev(pick.col))(200))
source("testing/plotSignatures.R")
par(mar=c(1,1,1,1))
plotSignatures(gap, my_palette, cexlab=1.2, cexlegend=1.2)

#Complex heatmap
#Set colour
require(RColorBrewer)
#myCol <- colorRampPalette(c("violet", "black", "springgreen"))(100)
myCol <- colorRampPalette(c("dodgerblue", "black", "yellow"))(100)
myBreaks <- seq(-3, 3, length.out=100)

require(ComplexHeatmap)

require(circlize)
require(cluster)

#Create a gradient colour for CD20 and other markers
require("RColorBrewer")

#Perform PAM on the genes (rows)
pamClusters <- gap$clustering
gap

varianceFactor <- 10

x <- as.matrix(get(AllSamples[1]))
x <- x[,-which(colnames(x) %in% c("DNA.1", "DeadLive"))]
x <- transform(x, BackgroundNoiseThreshold, EuclideanNormThreshold, transFun, asinhFactor)

#Select out the top markers based on variance
variances <- apply(x, 1, var)
x <- x[order(variances, decreasing=TRUE),]
x <- x[1:round((nrow(x)/varianceFactor),0),]

#x <- t(scale(t(x)))
x <- scale(x)

#Create a sample boxplot / violin plot
sampleBoxplot <- HeatmapAnnotation(boxplot=anno_boxplot(x, which="column", pch=".", size=unit(1.0, "mm"), border=TRUE, axis=TRUE))
#sampleAnno <- HeatmapAnnotation(boxplot=anno_boxplot(x, which="column", pch=".", size=unit(2.0, "mm"), border=TRUE, axis=TRUE), violin=anno_density(x, type="violin", which="column", size=unit(1.0, "mm"), border=FALSE, outline=TRUE, axis=TRUE))

annCD4 <- gap$clustering
annCD4[which(annCD4 %in% (grep("CD4\\+", gap$PositiveMarkers, invert=FALSE)))] <- "Positive"
annCD4[which(annCD4 %in% (grep("CD4\\+", gap$PositiveMarkers, invert=TRUE)))] <- "Negative"

annCD8 <- gap$clustering
annCD8[which(annCD8 %in% (grep("CD8\\+", gap$PositiveMarkers, invert=FALSE)))] <- "Positive"
annCD8[which(annCD8 %in% (grep("CD8\\+", gap$PositiveMarkers, invert=TRUE)))] <- "Negative"

annCD56 <- gap$clustering
annCD56[which(annCD56 %in% (grep("CD56\\+", gap$PositiveMarkers, invert=FALSE)))] <- "Positive"
annCD56[which(annCD56 %in% (grep("CD56\\+", gap$PositiveMarkers, invert=TRUE)))] <- "Negative"

rowAnn <- rowAnnotation(data.frame(CD4=annCD4, CD8=annCD8, CD56=annCD56), col=list(CD4=c("Positive"="skyblue", "Negative"="white"), CD8=c("Positive"="lawngreen", "Negative"="white"), CD56=c("Positive"="plum", "Negative"="white")), show_legend=TRUE, width=unit(1, "cm"))

par(mar=c(2,2,2,2), cex=0.8)

hmap <- Heatmap(x, name="Cell Z-score", col=colorRamp2(myBreaks, myCol),

    #heatmap_legend_param=list(color_bar="continuous", legend_direction="horizontal", labels=c("Low", "Mean", "High"), at=c(-4, 0, 4), title_position="lefttop", legend_width=unit(5,"cm")),
    heatmap_legend_param = list(color_bar = "continuous", legend_direction = "horizontal",
    legend_width = unit(5, "cm"), title_position = "lefttop"),
		split=paste0(pamClusters, "\n", round(gap$iPercentage[pamClusters], 2), "%"), gap=unit(1.5, "mm"),

		row_title="Genes", row_title_side="left", row_title_gp=gpar(fontsize=10,  fontface="bold"), show_row_names=FALSE, row_names_gp=gpar(fontsize=6, fontface="bold"), row_names_max_width=unit(2, "cm"),

		column_title="", column_title_side="top", column_title_gp=gpar(fontsize=10, fontface="bold"), column_title_rot=0, show_column_names=TRUE,

		#clustering_distance_columns="euclidean", clustering_method_columns="ward.D2",
		clustering_distance_columns=function(x) as.dist(1-cor(t(x))), clustering_method_columns="ward.D2",

		#clustering_distance_rows="euclidean", clustering_method_rows="ward.D2",
		clustering_distance_rows=function(x) as.dist(1-cor(t(x))), clustering_method_rows="ward.D2",

		row_dend_width=unit(20,"mm"), column_dend_height=unit(20,"mm"),

		#top_annotation=colAnn, top_annotation_height=unit(3,"cm"),
		#top_annotation=sampleViolin, top_annotation_height=unit(3,"cm"),

		top_annotation=sampleBoxplot, top_annotation_height=unit(3, "cm"))

	draw(hmap + rowAnn, heatmap_legend_side="bottom", annotation_legend_side="top")



#################################
#Graph and minimum spanning tree
#################################

require(igraph) 

g <- graph.adjacency(as.matrix(dist(gap$medoids)), mode="directed", weighted=TRUE, diag=TRUE)
V(g)$name <- V(g)$name
V(g)$label <- paste(gap$PositiveMarkers, gap$NegativeMarkers, sep="\n")
V(g)$color <- "white"
V(g)$shape <- "sphere"
V(g)$vertex.frame.color <- "white"
E(g)$color <- "grey"
E(g)$arrow.size <- 1.0

mst <- as.undirected(minimum.spanning.tree(g))
#mst <- as.directed(minimum.spanning.tree(g))

cd4t <- grep("CD4\\+", gap$PositiveMarkers)
cd8t <- grep("CD8\\+", gap$PositiveMarkers)
NK <- grep("CD56\\+", gap$PositiveMarkers)

V(g)[cd4t]$color <- "skyblue"
V(g)[cd8t]$color <- "lawngreen"
V(g)[NK]$color <- "plum"

V(mst)[cd4t]$color <- "skyblue"
V(mst)[cd8t]$color <- "lawngreen"
V(mst)[NK]$color <- "plum"

par(mar=c(1,1,1,1), cex=1.0, mfrow=c(1,2))

plot(g, main="Directed graph", layout=layout.graphopt, vertex.size=(gap$iPercentage)*3, vertex.label.dist=0, vertex.label.color="black", asp=FALSE, vertex.label.cex=0.8, edge.arrow.mode=1)

plot(mst, main="Minimal spanning tree", layout=layout.graphopt, vertex.size=(gap$iPercentage)*3, vertex.label.dist=0, vertex.label.color="black", asp=FALSE, vertex.label.cex=0.5, edge.arrow.mode=0, edge.width=3)
legend("topleft", bty="n", cex=0.8, title="Cell-type", c("Natural killer (CD56+)", "T (CD4+)", "T (CD8+)"), fill=c("plum", "skyblue", "lawngreen"), horiz=FALSE)

	###

	require(plotrix)
	V(g)$label <- V(g)$name
	mst <- as.undirected(minimum.spanning.tree(g))

	plot.new()
	table <- data.frame(c(1:k), round(gap$iPercentage, 2), gap$PositiveMarkers, gap$NegativeMarkers)
	colnames(table) <- c("Cluster #", "% cells", "Pos markers", "Neg markers")
	addtable2plot(0.05, 0.05, table, cex=0.6, bg="grey", lwd=3, bty="o", display.rownames=FALSE, hlines=TRUE, vlines=TRUE, title="Markers by cluster #")

	plot(mst, main="Minimal spanning tree", layout=layout.graphopt, vertex.size=(gap$iPercentage)*3, vertex.label.dist=0, vertex.label.color="black", asp=FALSE, vertex.label.cex=1.75, edge.arrow.mode=0, edge.width=3)
	legend("topleft", bty="n", cex=0.8, title="Cell-type", c("Natural killer (CD56+)", "T (CD4+)", "T (CD8+)"), fill=c("plum", "skyblue", "lawngreen"), horiz=FALSE)
dev.off()

#Look at cluster #2 and 24 individually
c2 <- x[gap$clustering==2,]
g2 <- graph.adjacency(as.matrix(dist(t(c2))), mode="directed", weighted=TRUE, diag=TRUE)
V(g2)$name <- V(g2)$name
V(g2)$color <- "gold"
V(g2)$shape <- "sphere"
V(g2)$vertex.frame.color <- "white"
E(g2)$color <- "grey"
E(g2)$arrow.size <- 1.0
mst2 <- as.directed(minimum.spanning.tree(g2))

c24 <- x[gap$clustering==24,]
g24 <- graph.adjacency(as.matrix(dist(t(c24))), mode="directed", weighted=TRUE, diag=TRUE)
V(g24)$name <- V(g24)$name
V(g24)$color <- "gold"
V(g24)$shape <- "sphere"
V(g24)$vertex.frame.color <- "white"
E(g24)$color <- "grey"
E(g24)$arrow.size <- 1.0
mst24 <- as.directed(minimum.spanning.tree(g24))

c17 <- x[gap$clustering==17,]
g17 <- graph.adjacency(as.matrix(dist(t(c17))), mode="directed", weighted=TRUE, diag=TRUE)
V(g17)$name <- V(g24)$name
V(g17)$color <- "gold"
V(g17)$shape <- "sphere"
V(g17)$vertex.frame.color <- "white"
E(g17)$color <- "grey"
E(g17)$arrow.size <- 1.0
mst17 <- as.directed(minimum.spanning.tree(g17))

c5 <- x[gap$clustering==5,]
g5 <- graph.adjacency(as.matrix(dist(t(c5))), mode="directed", weighted=TRUE, diag=TRUE)
V(g5)$name <- V(g24)$name
V(g5)$color <- "gold"
V(g5)$shape <- "sphere"
V(g5)$vertex.frame.color <- "white"
E(g5)$color <- "grey"
E(g5)$arrow.size <- 1.0
mst5 <- as.directed(minimum.spanning.tree(g5))

pdf("MST.clusters.pdf", width=15, height=7)
	par(mar=c(1,1,1,1), cex=1.0, mfrow=c(1,2))

	plot(g2, main="Directed graph\nCluster 2", layout=layout.graphopt, vertex.size=apply(c2, 2, mean)*2, vertex.label.dist=0, vertex.label.color="black", asp=FALSE, vertex.label.cex=1.0, edge.arrow.mode=1)

	plot(mst2, main="Minimal spanning tree\nCluster 2", layout=layout_nicely, vertex.size=apply(c2, 2, mean)*2, vertex.label.dist=0, vertex.label.color="black", asp=FALSE, vertex.label.cex=0.6, edge.arrow.mode=1, edge.width=3)

	###

	plot(g24, main="Directed graph\nCluster 24", layout=layout.graphopt, vertex.size=apply(c24, 2, mean)*2, vertex.label.dist=0, vertex.label.color="black", asp=FALSE, vertex.label.cex=1.0, edge.arrow.mode=1)

	plot(mst24, main="Minimal spanning tree\nCluster 24", layout=layout_nicely, vertex.size=apply(c24, 2, mean)*2, vertex.label.dist=0, vertex.label.color="black", asp=FALSE, vertex.label.cex=0.6, edge.arrow.mode=1, edge.width=3)

	###

	plot(g17, main="Directed graph\nCluster 17", layout=layout.graphopt, vertex.size=apply(c17, 2, mean)*2, vertex.label.dist=0, vertex.label.color="black", asp=FALSE, vertex.label.cex=1.0, edge.arrow.mode=1)

	plot(mst17, main="Minimal spanning tree\nCluster 17", layout=layout_nicely, vertex.size=apply(c17, 2, mean)*2, vertex.label.dist=0, vertex.label.color="black", asp=FALSE, vertex.label.cex=0.6, edge.arrow.mode=1, edge.width=3)

	###

	plot(g5, main="Directed graph\nCluster 5", layout=layout.graphopt, vertex.size=apply(c5, 2, mean)*2, vertex.label.dist=0, vertex.label.color="black", asp=FALSE, vertex.label.cex=1.0, edge.arrow.mode=1)

	plot(mst5, main="Minimal spanning tree\nCluster 5", layout=layout_nicely, vertex.size=apply(c5, 2, mean)*2, vertex.label.dist=0, vertex.label.color="black", asp=FALSE, vertex.label.cex=0.6, edge.arrow.mode=1, edge.width=3)
dev.off()





#Traveling Salesman
require(TSP)
pdf("TSP.pdf")
	par(mar=c(1,1,1,1), cex=1.0)

	i <- ETSP(gap$medoids)
	tour <- solve_TSP(i, method="nn", control="concorde")
	tour_length(tour)

	plot(i, tour, tour_col="red4")
dev.off()






x <- as.matrix(get(AllSamples[15]))
x <- x[,-which(colnames(x) %in% c("DNA.1", "DeadLive"))]
	
x <- x[apply(x, 1, FUN=function(x) sqrt(sum(x^2)))>EuclideanNormThreshold,]
NoiseCorrected <- x
NoiseCorrected[NoiseCorrected<BackgroundNoiseThreshold] <- 0
x <- transformation(NoiseCorrected/asinhFactor)

#Select out the top markers based on variance
variances <- apply(x, 1, var)
x <- x[order(variances, decreasing=TRUE),]
x2 <- x[1:round((nrow(x)/varianceFactor),0),]

#Voronoi diagram
library(tripack)
x <- prcomp(x2)$x[,1]
y <- prcomp(x2)$x[,2]
plot(voronoi.mosaic(x, y))
segments(x[i[,1]], y[i[,1]], x[i[,2]], y[i[,2]], lwd=3, col="grey")  
points(x, y, pch=3, cex=2, lwd=3)
box()

# Delaunay triangulation
# See also the "deldir" package
plot(tri.mesh(x,y))
plot(voronoi.mosaic(x, y), add=T, col="grey")
points(x, y, pch=3, cex=2, lwd=3)
























###


par(mar=c(5,5,5,5), cex=0.8)

		###

		#k-means dimensions plot

		clusplot(x, gap$clustering, main="kmeans clustering", color=TRUE, shade=TRUE, labels=1, lines=0)
		plotcluster(x, method="dc", gap$clustering, pch=19, xlab="Dimension 1", ylab="Dimension 2")
		plotcluster(x, method="wnc", gap$clustering, pch=19, xlab="Dimension 1", ylab="Dimension 2")

		###
























###

#Display the data as a pie chart
################################

StimulatedSamples <- AllSamples[grep("*_S_*", AllSamples)]
NonStimulatedSamples <- AllSamples[grep("*_NS_*", AllSamples)]

NewAllSamples <- c(NonStimulatedSamples, StimulatedSamples)

clusterinfo <- read.table("Variance/CountInformation.tsv", header=TRUE, sep="\t")

i <- 1

while (i < length(NewAllSamples))
{
	PieInfoSam1 <- clusterinfo[which(clusterinfo[,1] %in% NewAllSamples[i]),]
	Sam1Percentages <- PieInfoSam1[,3]
	Sam1Markers <- c()
	for (j in 1:nrow(PieInfoSam1))
	{
		Sam1Markers <- c(Sam1Markers, paste(paste(PieInfoSam1[j,4], sep="", collapse=""), paste(PieInfoSam1[j,5], sep="", collapse=""), sep="\n"))
	}

	PieInfoSam2 <- clusterinfo[which(clusterinfo[,1] %in% NewAllSamples[i+1]),]
	Sam2Percentages <- PieInfoSam2[,3]
	Sam2Markers <- c()
	for (j in 1:nrow(PieInfoSam2))
	{
		Sam2Markers <- c(Sam2Markers, paste(paste(PieInfoSam2[j,4], sep="", collapse=""), paste(PieInfoSam2[j,5], sep="", collapse=""), sep="\n"))
	}

	PieInfoSam3 <- clusterinfo[which(clusterinfo[,1] %in% NewAllSamples[i+2]),]
	Sam3Percentages <- PieInfoSam3[,3]
	Sam3Markers <- c()
	for (j in 1:nrow(PieInfoSam3))
	{
		Sam3Markers <- c(Sam3Markers, paste(paste(PieInfoSam3[j,4], sep="", collapse=""), paste(PieInfoSam3[j,5], sep="", collapse=""), sep="\n"))
	}

	pdf(paste("Variance/PieChart", gsub("_[A-Za-z0-9]*_", "_", NewAllSamples[i]), ".pdf", sep=""))
	{
		par(mar=c(5.5,5.5,5.5,5.5), cex=0.8, mfrow=c(2,2))

		pie(Sam1Percentages, labels=paste(Sam1Markers, paste(round(Sam1Percentages, 2), "%"), sep=", "), cex=0.3, cex.main=0.8, col=rainbow(length(Sam1Markers)), main=NewAllSamples[i])
		pie(Sam2Percentages, labels=paste(Sam2Markers, paste(round(Sam2Percentages, 2), "%"), sep=", "), cex=0.3, cex.main=0.8, col=rainbow(length(Sam2Markers)), main=NewAllSamples[i+1])
		pie(Sam3Percentages, labels=paste(Sam3Markers, paste(round(Sam3Percentages, 2), "%"), sep=", "), cex=0.3, cex.main=0.8, col=rainbow(length(Sam3Markers)), main=NewAllSamples[i+2])

		#biocLite("plotrix")
		library(plotrix)

		#pie3D(iClusterPercentages, labels=paste(Sam1Markers, paste(round(Sam1Percentages, 2), "%"), sep=", "), cex=0.3, cex.main=0.8, col=rainbow(length(Sam1Markers)), main=NewAllSamples[i], explode=0.1)
		#pie3D(iClusterPercentages, labels=paste(Sam2Markers, paste(round(Sam2Percentages, 2), "%"), sep=", "), cex=0.3, cex.main=0.8, col=rainbow(length(Sam2Markers)), main=NewAllSamples[i+1], explode=0.1)
		#pie3D(iClusterPercentages, labels=paste(Sam3Markers, paste(round(Sam3Percentages, 2), "%"), sep=", "), cex=0.3, cex.main=0.8, col=rainbow(length(Sam3Markers)), main=NewAllSamples[i+2], explode=0.1)
	}
	dev.off()

	i <- i + 3
	print(i)
}



#####
#END#
#####
